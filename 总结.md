# LinkerHand C++ SDK 架构设计文档

## 目录

1. [整体架构](#1-整体架构)
2. [生命周期管理](#2-生命周期管理)
3. [异步回调系统](#3-异步回调系统)
4. [线程安全设计](#4-线程安全设计)
5. [资源管理与清理](#5-资源管理与清理)
6. [数据流设计](#6-数据流设计)
7. [添加新设备示例](#7-添加新设备示例)

---

## 1. 整体架构

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户应用层                                │
│                    (User Application)                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        设备层（Device Layer）                     │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │   L6    │  │   L7    │  │   L10   │  │   L20   │  ...       │
│  │  Hand   │  │  Hand   │  │  Hand   │  │  Hand   │            │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Manager 层                                 │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐   │
│  │   Angle    │ │   Force    │ │   Torque   │ │   Speed    │   │
│  │  Manager   │ │  Sensor    │ │  Manager   │ │  Manager   │   │
│  └────────────┘ └────────────┘ └────────────┘ └────────────┘   │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐                  │
│  │Temperature │ │  Current   │ │   Fault    │                  │
│  │  Manager   │ │  Manager   │ │  Manager   │                  │
│  └────────────┘ └────────────┘ └────────────┘                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       基础设施层                                 │
│  ┌──────────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ CANMessageDispatcher │  │  Lifecycle   │  │  IterableQueue   │  │
│  │   (CAN 通信调度)   │  │ (生命周期管理) │  │   (数据队列)     │  │
│  └──────────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        系统层                                    │
│                   Linux SocketCAN API                           │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 核心组件职责

| 组件 | 职责 |
|------|------|
| **L6/L10/...（设备类）** | 统一入口，持有所有 Manager，管理共享生命周期 |
| **Manager** | 特定功能的数据采集与控制（角度、力传感器等） |
| **CANMessageDispatcher** | CAN 消息收发、订阅分发 |
| **Lifecycle** | 状态机管理，确保 close 后 API 行为一致 |
| **IterableQueue** | 线程安全的生产者-消费者队列，支持流式数据 |

---

## 2. 生命周期管理

### 2.1 设计目标

确保所有对外 API 在 `close()` 后具有一致的行为契约：
- **统一抛出 `StateError`**，而非未定义行为或不同类型的异常
- **阻塞操作立即唤醒**，不会等待超时
- **清理操作始终可执行**（如 `stop_streaming()`）

### 2.2 状态机设计

```
          ┌─────────────────────────────────────────┐
          │              Lifecycle                  │
          │  ┌───────┐              ┌────────┐     │
          │  │ Open  │─────────────▶│ Closed │     │
          │  └───────┘    close()   └────────┘     │
          │      │                       │         │
          │      ▼                       ▼         │
          │  允许操作                 拒绝操作      │
          │                         (StateError)   │
          └─────────────────────────────────────────┘
```

### 2.3 共享 Lifecycle 模式

```cpp
// L6 持有共享的 Lifecycle，传递给所有 Manager
class L6 {
  std::shared_ptr<Lifecycle> lifecycle_;  // 共享状态

  AngleManager angle;        // 共享同一个 lifecycle_
  ForceSensorManager force;  // 共享同一个 lifecycle_
  // ...
};

// Manager 在每个公开方法入口检查状态
void AngleManager::set_angles(const std::array<int, 6>& angles) {
  lifecycle_->ensure_open();  // 非 Open 状态抛 StateError
  impl_->set_angles(angles);
}
```

### 2.4 API 行为矩阵

| API 方法 | Open 状态 | Closing/Closed 状态 |
|----------|-----------|---------------------|
| `set_angles()` | 正常执行 | 抛出 `StateError` |
| `get_*_blocking()` | 正常执行 | 立即抛出 `StateError` |
| `get_current_*()` | 正常执行 | 抛出 `StateError` |
| `stream()` | 正常执行 | 抛出 `StateError` |
| `stop_streaming()` | 正常执行 | **正常执行**（清理操作） |
| `close()` | 执行关闭 | 幂等，直接返回 |
| `is_closed()` | 返回 `false` | 返回 `true` |

---

## 3. 回调系统

### 3.1 串行回调架构

CAN 消息接收和回调处理在同一线程串行执行，设计简单且满足当前需求：

```
┌─────────────────────────────────────────────────────────────┐
│                    CANMessageDispatcher                      │
│                                                              │
│  recv_thread（接收线程）：                                    │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  while (running) {                                      │ │
│  │    ① poll(10ms) 等待 CAN 消息                           │ │
│  │    ② read() 读取 CAN 帧                                 │ │
│  │    ③ for (sub : subscribers_copy) {                     │ │
│  │         if (sub->active.load()) {                       │ │
│  │           sub->callback(msg);  // 同步调用               │ │
│  │         }                                               │ │
│  │       }                                                 │ │
│  │  }                                                      │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

特点：
- 单线程处理，无并发复杂度
- 回调快速执行（内存操作为主，无 I/O）
- 适用于当前场景：回调仅做数据解析和状态更新
```

### 3.2 订阅者状态管理

`SubscriberState` 结构简洁，仅包含必要字段：

```cpp
struct SubscriberState {
  std::size_t id = 0;
  Callback callback;
  std::atomic<bool> active{true};  // 是否活跃

  void deactivate() { active.store(false, std::memory_order_release); }
};
```

### 3.3 退订流程

退订设计简洁，依赖架构保证而非复杂同步机制：

```cpp
void CANMessageDispatcher::unsubscribe(std::size_t subscription_id) {
  std::lock_guard<std::mutex> lock(subscribers_mutex_);
  auto it = find_subscriber(subscription_id);
  if (it == subscribers_.end()) return;

  (*it)->deactivate();   // 标记为非活跃，recv_loop 会跳过
  subscribers_.erase(it);
}
```

**架构约束**：安全性依赖于 `L6::close()` 的调用顺序——`dispatcher_.stop()` 会 join `recv_thread_`，确保在 Manager 析构前没有回调在执行。

---

## 4. 传感器多帧聚合

### 4.1 问题背景

力传感器数据量大（每个手指 72 字节），超过 CAN 帧的 8 字节限制，需要分多帧传输：

```
单个手指的力传感器数据：72 字节
CAN 帧有效载荷：6 字节（8 字节中 2 字节用于协议头）
所需帧数：72 / 6 = 12 帧
```

### 4.2 帧格式

```
CAN 帧结构（8 字节）：
┌──────────┬──────────┬──────────────────────────────────┐
│ data[0]  │ data[1]  │ data[2..7]                       │
│ 命令前缀  │ 帧索引    │ 6 字节有效载荷                    │
│ (0xB1-B5)│ (高4位)  │                                  │
└──────────┴──────────┴──────────────────────────────────┘

命令前缀：
- 0xB1: 拇指 (thumb)
- 0xB2: 食指 (index)
- 0xB3: 中指 (middle)
- 0xB4: 无名指 (ring)
- 0xB5: 小指 (pinky)

帧索引：0x00, 0x10, 0x20, ... 0xB0（对应 0-11 帧）
```

### 4.3 聚合状态机

```cpp
struct FrameBatch {
  std::array<std::optional<std::array<uint8_t, 6>>, 12> frames{};
  std::size_t count = 0;           // 已收到的帧数
  double started_at = now();       // 开始时间（可用于超时检测）

  // 添加一帧数据，返回新的 FrameBatch（不可变更新）
  FrameBatch add_frame(std::size_t frame_id, const std::array<uint8_t, 6>& data) const {
    FrameBatch next = *this;
    if (!next.frames[frame_id].has_value()) {
      next.count += 1;
    }
    next.frames[frame_id] = data;
    return next;
  }

  bool is_complete() const { return count == 12; }

  // 组装完整数据
  ForceSensorData assemble() const {
    ForceSensorData out{};
    std::size_t offset = 0;
    for (std::size_t i = 0; i < 12; ++i) {
      for (std::size_t j = 0; j < 6; ++j) {
        out.values[offset++] = (*frames[i])[j];
      }
    }
    out.timestamp = now();
    return out;
  }
};
```

### 4.4 消息处理流程

```cpp
void on_message(const CanMessage& msg) {
  // 1. 过滤：检查 arbitration_id 和命令前缀
  if (msg.arbitration_id != arbitration_id) return;
  if (msg.dlc < 8 || msg.data[0] != command_prefix) return;

  // 2. 解析帧索引
  const std::size_t frame_idx = msg.data[1] >> 4;  // 高 4 位
  if (frame_idx >= 12) return;

  // 3. 提取有效载荷
  std::array<uint8_t, 6> frame_data{};
  for (std::size_t i = 0; i < 6; ++i) {
    frame_data[i] = msg.data[2 + i];
  }

  // 4. 添加到 FrameBatch
  if (!frame_batch.has_value()) {
    frame_batch = FrameBatch{};
  }
  frame_batch = frame_batch->add_frame(frame_idx, frame_data);

  // 5. 检查是否完整
  if (!frame_batch->is_complete()) {
    return;  // 继续等待后续帧
  }

  // 6. 组装并分发
  const ForceSensorData complete_data = frame_batch->assemble();
  frame_batch.reset();  // 重置，准备接收下一批
  on_complete_data(complete_data);
}
```

### 4.5 数据流图

```
CAN 总线                         SingleForceSensorManager
    │                                     │
    ▼                                     ▼
┌─────────┐                        ┌─────────────┐
│ Frame 0 │───┐                    │ FrameBatch  │
│(0xB1,0x00)│  │                    │ frames[0]   │
└─────────┘  │                     │ frames[1]   │
┌─────────┐  │  on_message()       │ frames[2]   │
│ Frame 1 │──┼─────────────────────▶│ ...         │
│(0xB1,0x10)│  │                    │ frames[11]  │
└─────────┘  │                     │ count: 0→12 │
    ...      │                     └──────┬──────┘
┌─────────┐  │                            │
│Frame 11 │──┘                            │ is_complete()
│(0xB1,0xB0)│                              ▼
└─────────┘                        ┌─────────────┐
                                   │  assemble() │
                                   └──────┬──────┘
                                          │
                                          ▼
                                   ┌─────────────┐
                                   │ForceSensorData│
                                   │ values[72]  │
                                   │ timestamp   │
                                   └─────────────┘
```

### 4.6 设计要点

| 要点 | 说明 |
|------|------|
| **不可变更新** | `add_frame` 返回新对象，避免部分更新导致的数据不一致 |
| **幂等处理** | 同一帧重复到达会覆盖旧数据，count 不会重复增加 |
| **无超时机制** | 当前假设帧会连续到达，不处理部分丢帧情况 |
| **每手指独立** | 5 个 `SingleForceSensorManager` 各自维护 `FrameBatch` |

---

## 5. 线程安全设计

### 5.1 双重检查模式

在关键操作前后进行状态检查，防止 TOCTOU（Time-of-Check to Time-of-Use）问题：

```cpp
void CANMessageDispatcher::send(const CanMessage& msg) {
  // 第一次检查（无锁快速路径）
  if (!running_.load(std::memory_order_acquire)) {
    throw StateError("CAN dispatcher is stopped");
  }

  std::lock_guard<std::mutex> lock(socket_mutex_);

  // 第二次检查（持锁确认）
  if (!running_.load(std::memory_order_acquire)) {
    throw StateError("CAN dispatcher is stopped");
  }

  // 安全执行写操作
  ::write(socket_fd_, &frame, sizeof(frame));
}
```

### 5.2 锁的层次结构

```
锁获取顺序（避免死锁）：
┌──────────────────────────────────────────────┐
│  subscribers_mutex_  (订阅者列表锁)           │
│       │                                      │
│       ▼                                      │
│  socket_mutex_  (Socket 写锁)                │
└──────────────────────────────────────────────┘

规则：获取锁必须按此顺序，释放锁按相反顺序
```

### 5.3 原子操作使用

```cpp
// 状态标志使用 atomic，避免数据竞争
std::atomic<bool> running_{false};
std::atomic<bool> streaming_running_{false};

// 内存序选择
running_.store(true, std::memory_order_release);   // 写操作
running_.load(std::memory_order_acquire);          // 读操作
closed_.exchange(true, std::memory_order_acq_rel); // 读-改-写
```

---

## 6. 资源管理与清理

### 6.1 RAII 与析构顺序

```cpp
class L6 {
  // 成员声明顺序决定析构顺序（逆序析构）
  std::shared_ptr<Lifecycle> lifecycle_;  // 最后析构
  CANMessageDispatcher dispatcher_;       // 倒数第二

  AngleManager angle;         // 依赖 dispatcher_，先析构
  ForceSensorManager force;   // 依赖 dispatcher_，先析构
  // ...

  ~L6() {
    try {
      close();  // 显式清理，确保有序关闭
    } catch (...) {}
  }
};
```

### 6.2 关闭流程

```cpp
void L6::close() {
  // 1. 幂等关闭：设置状态为 Closed 并通知所有订阅者
  //    返回 false 表示已经关闭过，直接返回
  if (!lifecycle_->close()) {
    return;
  }

  // 2. 停止所有流式数据（清理操作，close 后仍可执行）
  try {
    force_sensor.stop_streaming();
    angle.stop_streaming();
  } catch (...) {}

  // 3. 停止通信层
  try {
    dispatcher_.stop();
  } catch (...) {}
}
```

### 6.3 Manager 的 Pimpl 模式

```cpp
class AngleManager {
 public:
  AngleManager(uint32_t id, CANMessageDispatcher& d, std::shared_ptr<Lifecycle> lc);
  ~AngleManager();  // = default，自动析构 impl_

 private:
  struct Impl;                    // 前向声明
  std::unique_ptr<Impl> impl_;    // 实现细节隐藏
  std::shared_ptr<Lifecycle> lifecycle_;
};

// Impl 析构时自动清理
AngleManager::Impl::~Impl() {
  try { stop_streaming(); } catch (...) {}
  try { lifecycle->unsubscribe(subscription_id); } catch (...) {}
  dispatcher.unsubscribe(can_subscription_id);
}
```

---

## 7. 数据流设计

### 7.1 阻塞式数据获取

```cpp
AngleData get_angles_blocking(double timeout_ms) {
  // 1. 创建等待者对象
  auto waiter = std::make_shared<AngleWaiter>();
  {
    std::lock_guard<std::mutex> lock(waiters_mutex);
    waiters.push_back(waiter);
  }

  // 2. 发送数据请求（如果不在流式模式）
  if (!is_streaming) {
    send_sense_request();
  }

  // 3. 条件变量等待，支持超时和生命周期感知
  std::unique_lock<std::mutex> lock(waiter->mutex);
  bool ok = waiter->cv.wait_for(lock, timeout, [&] {
    return waiter->ready ||
           lifecycle->state() != LifecycleState::Open;  // 生命周期感知
  });

  // 4. 返回数据或抛出异常
  if (ok && waiter->data.has_value()) {
    return *waiter->data;
  }

  // 清理等待者
  remove_waiter(waiter);

  // 优先检查生命周期（close 时抛 StateError 而非 TimeoutError）
  lifecycle->ensure_open();
  throw TimeoutError("No data received within timeout");
}
```

### 7.2 流式数据获取

```
┌──────────────────────────────────────────────────────────────┐
│                        流式数据流程                           │
│                                                              │
│  stream() 调用                                               │
│       │                                                      │
│       ▼                                                      │
│  ┌─────────────────┐     ┌─────────────────┐                │
│  │ Streaming Thread│────▶│ IterableQueue   │                │
│  │ (定时发送请求)   │     │ (线程安全队列)   │                │
│  └─────────────────┘     └─────────────────┘                │
│                                 │                            │
│                                 ▼                            │
│                          用户迭代消费                         │
│                          for (data : queue)                  │
│                                                              │
│  stop_streaming() 或 close()                                 │
│       │                                                      │
│       ▼                                                      │
│  queue.close() → 迭代器抛出 StopIteration                    │
└──────────────────────────────────────────────────────────────┘
```

---

## 8. 添加新型号手示例

以添加一个新型号 `L10`（10 自由度灵巧手）为例，与 `l6` 目录同级。

### 8.1 目录结构

```
include/linkerhand/hand/
├── l6/                          # 现有 L6 手
│   ├── l6.hpp
│   ├── angle_manager.hpp
│   └── force_sensor_manager.hpp
└── l10/                         # 新增 L10 手
    ├── l10.hpp                  # Facade 类
    └── angle_manager.hpp        # 可复用或自定义的 Manager

src/hand/
├── l6/
│   ├── l6.cpp
│   └── angle_manager.cpp
├── l10/                         # 新增
│   ├── l10.cpp
│   └── angle_manager.cpp
└── common.hpp                   # 共享工具函数
```

### 8.2 设备类头文件

```cpp
// include/linkerhand/hand/l10/l10.hpp
#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "linkerhand/can_dispatcher.hpp"
#include "linkerhand/lifecycle.hpp"
#include "linkerhand/hand/l10/angle_manager.hpp"

namespace linkerhand::hand::l10 {

class L10 {
 private:
  std::shared_ptr<linkerhand::Lifecycle> lifecycle_;
  CANMessageDispatcher dispatcher_;
  std::uint32_t arbitration_id_ = 0x30;  // L10 特有的 CAN ID

 public:
  L10(const std::string& side,
      const std::string& interface_name,
      const std::string& interface_type = "socketcan");
  ~L10();

  L10(const L10&) = delete;
  L10& operator=(const L10&) = delete;

  // L10 特有的 Manager（10 自由度角度控制）
  AngleManager angle;

  void close();
  bool is_closed() const;
};

}  // namespace linkerhand::hand::l10
```

### 8.3 设备 类实现

```cpp
// src/hand/l10/l10.cpp
#include "linkerhand/hand/l10/l10.hpp"

namespace linkerhand::hand::l10 {

L10::L10(const std::string& side,
         const std::string& interface_name,
         const std::string& interface_type)
    : lifecycle_(std::make_shared<linkerhand::Lifecycle>("L10")),
      dispatcher_(interface_name, interface_type),
      arbitration_id_(side == "right" ? 0x2F : 0x30),  // L10 的 CAN ID
      angle(arbitration_id_, dispatcher_, lifecycle_) {}

L10::~L10() {
  try {
    close();
  } catch (...) {}
}

void L10::close() {
  // 幂等关闭：返回 false 表示已经关闭过
  if (!lifecycle_->close()) {
    return;
  }

  // 停止所有流式数据
  try {
    angle.stop_streaming();
  } catch (...) {}

  // 停止通信层
  try {
    dispatcher_.stop();
  } catch (...) {}
}

bool L10::is_closed() const {
  return lifecycle_->is_closed();
}

}  // namespace linkerhand::hand::l10
```

### 8.4 自定义 Manager（协议不同时）

如果 L10 的角度控制协议与 L6 不同，需要自定义 Manager：

```cpp
// include/linkerhand/hand/l10/angle_manager.hpp
#pragma once

#include <array>
#include <cstdint>
#include <memory>
#include <optional>

#include "linkerhand/can_dispatcher.hpp"
#include "linkerhand/iterable_queue.hpp"
#include "linkerhand/lifecycle.hpp"

namespace linkerhand::hand::l10 {

// L10 是 10 自由度，数据结构不同于 L6
struct AngleData {
  std::array<int, 10> angles{};  // 10 个关节角度
  double timestamp = 0.0;
};

class AngleManager {
 public:
  AngleManager(std::uint32_t arbitration_id, CANMessageDispatcher& dispatcher);
  AngleManager(
      std::uint32_t arbitration_id,
      CANMessageDispatcher& dispatcher,
      std::shared_ptr<linkerhand::Lifecycle> lifecycle);
  ~AngleManager();

  AngleManager(const AngleManager&) = delete;
  AngleManager& operator=(const AngleManager&) = delete;

  // L10 特有：10 个角度
  void set_angles(const std::array<int, 10>& angles);

  AngleData get_angles_blocking(double timeout_ms = 100);
  std::optional<AngleData> get_current_angles() const;

  IterableQueue<AngleData> stream(double interval_ms = 100, std::size_t maxsize = 100);
  void stop_streaming();

 private:
  struct Impl;
  std::unique_ptr<Impl> impl_;
  std::shared_ptr<linkerhand::Lifecycle> lifecycle_;
};

}  // namespace linkerhand::hand::l10
```

### 8.5 设计原则：独立实现

> **核心原则：每个型号独立实现**
>
> 添加新设备时，**不使用继承或组合包装**，而是为每个型号创建**独立的完整实现**：
> - 每个型号一个独立文件夹
> - 每个型号一个设备类（如 `L6`、`L10`）
> - 文件夹内包含该型号所需的所有 Manager
> - 可参考其他型号的代码进行复制和修改
>
> **为什么不使用继承？**
> - 紧耦合：子类与父类实现细节绑定
> - 脆弱基类问题：父类修改可能破坏子类
> - 不同型号的协议差异往往较大，强行复用反而增加复杂度
>
> **为什么不使用组合包装？**
> - 增加不必要的间接层
> - 不同型号之间通常没有真正的复用关系
> - 独立实现更清晰、更易维护
> - 主要是可能会出现一个手的功能变化，另一个手的功能不会变化
#### 推荐的目录结构

```
include/linkerhand/hand/
├── l6/                          # L6 型号（独立完整）
│   ├── l6.hpp                   # L6 设备类
│   ├── angle_manager.hpp
│   └── force_sensor_manager.hpp
├── l10/                         # L10 型号（独立完整）
│   ├── l10.hpp                  # L10 设备类
│   ├── angle_manager.hpp        # L10 自己的实现，可参考 L6
│   └── force_sensor_manager.hpp
└── l20/                         # L20 型号（独立完整）
    ├── l20.hpp
    └── ...

src/hand/
├── l6/
│   ├── l6.cpp
│   ├── angle_manager.cpp
│   └── force_sensor_manager.cpp
├── l10/
│   ├── l10.cpp
│   ├── angle_manager.cpp        # 独立实现，不依赖 l6
│   └── force_sensor_manager.cpp
└── l20/
    └── ...
```

#### 代码复用方式

```cpp
// 正确方式：独立实现
// L10 的 AngleManager 参考 L6 的实现，但完全独立

// include/linkerhand/hand/l10/angle_manager.hpp
namespace linkerhand::hand::l10 {

struct AngleData {
  std::array<int, 10> angles{};  // L10 是 10 自由度
  double timestamp = 0.0;
};

class AngleManager {
 public:
  AngleManager(std::uint32_t arbitration_id,
               CANMessageDispatcher& dispatcher,
               std::shared_ptr<linkerhand::Lifecycle> lifecycle);
  ~AngleManager();

  void set_angles(const std::array<int, 10>& angles);  // L10 特有
  AngleData get_angles_blocking(double timeout_ms = 100);
  // ...

 private:
  struct Impl;
  std::unique_ptr<Impl> impl_;
  std::shared_ptr<linkerhand::Lifecycle> lifecycle_;
};

}  // namespace linkerhand::hand::l10
```

```cpp
// 错误方式：不要使用继承
// class L10AngleManager : public l6::AngleManager { ... }  // ❌

```

### 8.6 注册到统一入口（可选）

```cpp
// include/linkerhand/linkerhand.hpp
#pragma once

#include "linkerhand/hand/l6/l6.hpp"
#include "linkerhand/hand/l10/l10.hpp"

namespace linkerhand {

// 便捷别名
using L6 = hand::l6::L6;
using L10 = hand::l10::L10;

}  // namespace linkerhand
```

### 8.7 使用示例

```cpp
#include "linkerhand/linkerhand.hpp"

int main() {
  // 使用 L6（6 自由度）
  linkerhand::L6 hand_l6("left", "can0");
  hand_l6.angle.set_angles({100, 100, 100, 100, 100, 100});

  // 使用 L10（10 自由度）
  linkerhand::L10 hand_l10("right", "can1");
  hand_l10.angle.set_angles({100, 100, 100, 100, 100, 100, 100, 100, 100, 100});

  // 关闭
  hand_l6.close();
  hand_l10.close();

  return 0;
}
```

### 8.8 关键要点总结

| 要点 | 说明 |
|------|------|
| **一个型号一个文件夹** | 每个型号完全独立，如 `l6/`、`l10/`、`l20/` |
| **一个型号一个设备类** | 每个型号有自己的设备类（如 `L6`、`L10`），文件夹下包含多个 Manager |
| **独立实现，不使用继承** | 新型号通过复制参考代码独立实现，**不使用继承或组合包装** |
| **复用基础设施** | 共享 `Lifecycle`、`CANMessageDispatcher`、`IterableQueue` 等基础组件 |
| **自定义协议参数** | CAN ID、命令字节、数据结构可按需调整 |
| **保持一致的生命周期契约** | 新设备必须遵循相同的 close 后抛 StateError 行为 |
| **统一入口注册** | 在 `linkerhand.hpp` 中暴露，方便用户使用 |
